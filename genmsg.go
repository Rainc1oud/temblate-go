// temblate is a generator for language-message-mapped templates as a literal map
// invoke by
// go generate
package temblate_go

import (
	"fmt"
	"io/ioutil"
	"os"
	"path/filepath"
	"regexp"
	"strings"
)

// var langmsg *langTemplates = make(map[string]map[string]string, 0)

const goTmpl = `// generated by:
// go generate
// DO NOT EDIT

package temblate_go

func init() {
	templates = %#v
}
`

// func main() {
// 	if err := generate("./temblate/messages.go", "./temblate/"); err != nil {
// 		fmt.Fprintf(os.Stderr, "ERROR: %s", err.Error())
// 	}
// }

func Generate(tgtfile, tmpldir string) error {
	msgs := fmt.Sprintf(goTmpl, *readTemplates(tmpldir))
	msgs = strings.ReplaceAll(msgs, "temblate_go.", "") // somehow %#v adds the package scope, which we don't want
	return ioutil.WriteFile(tgtfile, []byte(msgs), 0600)
}

func readTemplates(dir string) *messageTemplates {
	// tpls := new(temblate.langTemplates)
	tpls := make(messageTemplates)
	re, err := regexp.Compile(`(\w*)\.([a-z]{2,3})\.gotmpl`)
	if err != nil {
		fmt.Fprintf(os.Stderr, "FATAL: %s", err.Error())
		return &tpls
	}

	tfn, err := filepath.Glob(filepath.Join(dir, "*.gotmpl"))
	fmt.Fprintf(os.Stderr, "DEBUG: tfn==%v\n", tfn)
	if err != nil {
		fmt.Fprintf(os.Stderr, "ERROR: couldn't find template files in %s (%s)\n", dir, err.Error())
		return &tpls
	}

	for _, fn := range tfn {
		tn := filepath.Base(fn)
		if m := re.FindStringSubmatch(tn); len(m) == 3 {
			fmt.Fprintf(os.Stderr, "found template msg[%s]lang[%s] in %s\n", m[1], m[2], tn)
			if tc, err := ioutil.ReadFile(fn); err == nil {
				if tpls[m[1]] == nil {
					tpls[m[1]] = make(langTemplates)
				}
				tpls[m[1]][m[2]] = string(tc)
			}
		} else {
			fmt.Fprintf(os.Stderr, "filename %s not in valid template format (matches: %v)\n", tn, m)
		}
	}
	return &tpls
}
